\section{Задача}
Как говорилось выше, для корректной работы Deepsolver необходимо
поддерживать актуальное состояние индекса. Одной из составляющих
этой проблемы является обеспечение целостности. Таким образом, первая
задача настоящей работы может быть сформулирована, как: ``создание
утилиты для тестирования целостности репозитория''.
Помимо проверки статического состояния репозитория, существует необходимость
проверки корректности алгоритмов удаления или добавления пакета. Таким образом,
постановка второй задачи: ``тестирование утилит ds-patch и ds-provides для обновления
индекса''.

В качестве языка программирования для реализации решения был выбран Python.
Решение состоит из трех частей:
\begin{itemize}
\item{ds_test.py - основной модуль, содержащий функции, используемые
для решения обеих задач.}
\item{В ds_index_test.py реализовано тестирования готового индекса репозитория.}
\item{В ds_patch_util_test.py реализовано тестирование утилит для обновления
индекса.}
\end{itemize}

\subsection{Входные данные}
Выше упоминалось , что вспомогательная информация о наборе пакетов репозитория
хранится в индексе. У Deepsolver в каталоге base.*, предназначенного для хранения индекса,
содержатся следующие файлы:
\begin{itemize}
\item{\textit{info} --- информационный файл с параметрами индекса;} 
\item{\textit{rpms.complete.data) --- вспомогательный файл, не предназначенный
для загрузки пользователями, с информацией для повторной фильтрации
provides;}
\item{\textit{rpms.data} --- основной список пакетов с информацией о зависимостях между ними;}
\item{\textit{rpms.descr.data} --- список пакетов с расширенными описаниями;}
\item{\textit{rpms.ﬁlelist.data} --- списки файлов для каждого бинарного пакета;}
\item{\textit{srpms.data} --- основная информация о пакетах с исходными текстами;}
\item{\textit{srpms.descr.data} --- список пакетов с исходными текстами, содержащий
расширенную информацию.}
\end{itemize} 
Каталог  $base.*$ существует для каждой архитектуры, $i586$ $x86\_64$, пакеты,
независящие от архитектуры, содержаться в каталоге $noarch$.


Для тестирования целостности репозитория используются данные из файла rpms.data,
в котором описание каждого пакета соответствует следующему формату:
\begin{itemize}
\item{[name-version-release.architecture.rpm] }
\item{n=name} %%расшифровка?
\item{e=epoch}
\item{v=version}
\item{r=release}
\item{arch=architecture}
\item{btime=build time}%%FIXME: btime-?
\item{p:provide}
\item{r:require}
\item{c:conflict}
\item{o:obsolete}
\end{itemize}
Очевидно, что каждому пакету соответствует набор множеств provides,
requires, conflicts, obsoletes, которые могут быть и пустыми.

А для второго этапа тестирования на вход поступает не конкретный файл, а
каталог base.*, так как утилиты ds-patch и ds-provides используют данные
всех файлов из директории.

\subsection{Модуль ds_test.py}
ds_test.py предоставляет основную функциональность утилиты  как для тестирования
готового индекса, так и для проверки после обновления. Ниже представлена диаграмма
классов данного модуля.
%%FIXME:Диаграмма классов
Package - это класс, объекты которого представляют отдельные пакеты и, как видно из диаграммы,
содержат информацию а пакете, если сопоставлять: полю name соответствует строка, заключенная
в квадратные скобки, полю short_name - строка, идущая ниже, а provides, requires
и conflicts - это массивы строк, соответствующие одноименным множествам пакета. 

Класс IndexParser отвечает за разбор файлов индекса, в качестве параметра конструктора
ожидается файл, который необходимо обработать. Метод _append_index_filename получает на вход
имя директории с целевым файлом и образует из него и имени файла для парсинга
путь.
Основным методом класса IndexParser является get_packages_from_index_file.
В качестве входных данных используется сформированный ранее путь к файлу с данными
для парсинга. Этот метод возвращает генератор массива объектов класса Package.

Тот факт, что метод get_packages_from_index_file возвращает генератор позволяет
его использовать в том числе и для парсинга сразу нескольких файлов. Это происходит
в методе get_packages_from_index_files, который на вход получает массивов файлов, 
затем для каждого файлы вызывает предыдущий метод. Этот метод так же возвращает
генератор массива объектов класса Package.

Класс IndexTestResult предназначен для удобной работы с результатами тестирования. 
У этого класса есть три метода отвечающие за накопление результатов тестирования:
add_unmatched_provide, add_unmatched_require и add_unmatched_conflict, каждый из которых
в качестве первого аргумента получает объект класса Package - текущий пакет, а в качестве второго
- строку, соответствующую повреждению(из множества provides, requires или conflicts).
Для управления выводом переопределен метод __str__. Так же у класса существует метод diff,
принимающий в качестве аргумента объект класса IndexTestResult. Назначение метода 
заключается в том, чтобы при существовании двух результатов тестирования (объектов
класса IndexTestResult) второй содержал только новые повреждения, то есть отсутствующие
в первом.

В классе IndexTester определены методы, непосредственно отвечающие за тестирование
индекса. При создании объекта данного класса в конструкторе передается файл с директориями,
в которых может находится provide, не считаясь избыточным. 
Алгоритм тестирования реализован в методе test_index. Этот метод на вход
получает массив объектов класса Package. Алгоритм выглядит следующим образом:
\begin{enumerate}
\item{Инициализация списка имен пакетов - names_set, списка provides и %%FIXME:корректно ли называть сеты списками? нормально
списка requires_conflicts}
\item{Совершается проход в цикле по всем пакетам. На каждом шаге 
к уже сформированным спискам provides, requires_conflicts и names_set 
добавляются данные пакета. В результате получаем набор списков всех provides, 
requires_conflict и имен для набора пакетов}
\item{Создается объект класса IndexTestResult}
\item{Совершается проход в цикле по всем пакетам. На каждом шаге цикла проверяется
\begin{itemize}
\item{Для каждого provide пакета проверяется является ли он избыточным: существует ли
строка из списка requires_conflicts или находится ли он в одной из заданных директорий.
Если не является, то данный пакет помечается, как поврежденный, а данный provide помечается,
как избыточный, то есть вызывается метод add_unmatched_provide у объекта класса IndexTestResult}
\item{Для каждого require пакета проверяется не является ли он анметом: существует ли
соответствующая строка из списка provides. Если не существует, то пакет помечается, как 
поврежденный, а require, как анмет, то есть вызывается метод add_unmatched_require
у объекта класса IndexTestResult}
\item{Для каждого conflict пакета проверяется не является ли он избыточным: существует ли
соответствующая строка из списка provides. Если не существует, то пакет помечается, как 
поврежденный, а conflict, как поврежденный, то есть вызывается метод add_unmatched_conflict
у объекта класса IndexTestResult}
\end{itemize}
\item{Возвращается объект класса IndexTestResult}

\subsection{Утилита для тестирования целостности репозитория}
Под целостностью репозитория понимается состояние, для которого
верны следующие утверждения:
\begin{itemize}
\item{Для каждого require пакета существует одноименный provide 
другого пакета. Require, для которого это условие не выполняется
называется \i анметом (unmet). }
\item{Для каждого provide существует одноименный require/conflict или
он находится в директории из заранее заданного списка.Это условие 
контролирует появление избыточных provide, засчет которых %%FIXME:сделать ссылку на место, где про это говорилось
может существенно расти размер индекса.}
\item{Для каждого conflict пакета существует одноименный provide 
другого пакета. Это условие не является таким строгим, как два предыдущих,
но желательно, чтобы оно выполнялось. }

Формат вызова ds_index_test.py выглядит следующим образом:
$ds_index_test.py [-h] DIRECTORY_FILE INDEX_FILE [INDEX_FILE ...]]$, где
DIRECTORY_FILE --- текстовый файл со списком директорий для provide.
INDEX_FILE --- файл с индексом формата gunzip.

Таким образом, первый этап проверки сводится к выполнению следующих действий:
\begin{itemize}
\item{Создание объектов класса IndexParser и IndexTester.}
\item{Создание и заполнение массива объектов класса Package при помощи
вызова метода get_packages_from_index_files у объекта класса IndexParser.}
\item{Получение результатов тестирования посредством вызова метода test_index
у объекта класса IndexTester}



\subsection{Проверка утилит для обновления индекса}
Под утилитами для обновления индекса подразумеваются описанные
выше ds-patch и ds_provides.
Вызов этой утилиты выглядит следующим образом:
ds_patch_util_test.py [-h] DIRECTORY_FILE INDEX_FILES_PATH [INDEX_FILES_PATH ...], где
DIRECTORY_FILE --- текстовый файл со списком директорий для provide.
INDEX_FILES_PATH --- директория, содержащая файлы с индексом.

Проверка представляет собой последовательность действий:
\begin{itemize}
\item{Проведение начального тестирования на неизменном индексе. Сохранение
и вывод результатов.}
\item{Совершаем проход в цикле по каждой директории из INDEX_FILES_PATH. На
каждом шаге:
	\begin{itemize}
	\item{Формируем список пакетов для текущей директории.}
	\item{Для каждого пакета из списка вызывается утилита ds_patch 
	для текущего пакета, затем ds-provides для директории файла, а 
	так же связанных с ней. После этого проводится тестирование
	измененного индекса и вывод результатов отличных от начальных
	с использование метода diff объекта класса IndexTestResult.}
}






