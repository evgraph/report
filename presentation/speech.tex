
\documentclass[a4paper]{article}

\usepackage[russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{cmap}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{sectsty}
\usepackage{fancyhdr}
\usepackage{longtable}
\usepackage{url}
\usepackage{appendix}
\usepackage{enumerate}

\newcommand{\EN}[1]{{#1}}
\newcommand{\CODE}[1]{{\ttfamily #1}}

\fancyhf{}
\fancyfoot[C]{\Large \thepage}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

%%Modifying captions for figures and tables:
\makeatletter
\long\def\@makecaption#1#2{%
\vspace{\abovecaptionskip}%
\sbox{\@tempboxa}{\Large #1.~#2}
\ifdim \wd\@tempboxa >\hsize
{\Large #1.~#2}\par
\else
\global\@minipagefalse
\hbox to \hsize {\hfill {\Large #1.~#2}\hfill}%
\fi
\vspace{\belowcaptionskip}}

\renewcommand{\baselinestretch}{1.2}
%%\sectionfont{\LARGE}
\sectionfont{\Large}
\subsectionfont{\Large}
\subsubsectionfont{\Large}
\setlength{\belowcaptionskip}{6pt}
\makeatletter \renewcommand{\@biblabel}[1]{#1.\hfill}

\makeatletter 
\def\redeflsection{\def\l@section{\@dottedtocline{1}{1.5em}{7.8em}}} 
\renewcommand\appendix{\par 
\setcounter{section}{0}% 
\setcounter{subsection}{0}% 
\def\@chapapp{\appendixname}% 
\addtocontents{toc}{\protect\redeflsection} 
\def\thesection{\appendixname\hspace{0.2cm}\@Asbuk\c@section}} 
\makeatother 

\textwidth = 17cm
\oddsidemargin= 0 pt
\topmargin = -1cm
\headheight = 0cm
\headsep = 0cm
\textheight = 26.5cm

\begin{document}
%\huge


На современные компьютеры необходимо устанавливать сотни программ.
В операционной системе Линукс существует своя собственная модель 
для дистрибуции ПО, центральным элементом которой является репозиторий 
- хранилище программ, находящееся в сети. Основным свойством репозитория
 является целостность, что подразумевает возможность установки 
пользователем любого ПО, в нем находящегося. Обеспечение этого 
свойства составляет одну из основных задач утилит для работы с 
репозиторием. Целью настоящей работы является создание программного 
продукта, проверяющего целостностноть репозитория, по сути, качество работы упомянутых утилит.

В ос Линукс программа представляет собой пакет - файл, содержащий 
информацию о продукте, программные файлы и документацию.Пакеты 
находятся в централизованном хранилище в сети - репозитории. 
Пакеты внутри репозитория имеют множество связей с другими пакетами, 
называемых зависимостями. Поэтому для корректного добавления, удаления, 
обновления пакетов, а так же их установки необходимы специальные программы 
- пакетные менеджеры.


Выделяют два уровня пакетных менеджеров. Пакетные менеджеры первого уровня
обеспечивают непосредственно добавление, удаление и обновление пакетов. 
Для осуществления поиска пакета для установки по заданным поьзователем 
параметрам, учитывая зависимости между пакетами, применяются пакетные менеджеры
второго уровня. 

В репозитории хранится вспомогательная информация о пакетах, включающая 
информацию о зависимостях, называемая индексом. Пакет может предоставлять 
функциональность другого пакета, указывая об этом информацию в тэге provide. 
Так же допустимы следующие типы отношений на множестве пакетов, информация 
о которых так же содержится в индексе:
\begin{itemize}
\item
Requires : пакет требует обязательное наличие другого пакета, указанного 
по его имени или по одному из его provides.
\item
Conflicts :
пакет запрещает наличие другого пакета, указанного по его имени или по
provides.
\item 
Obsoletes: Пакет может указывать, что является обновлением некоторого 
множества пакетов. 
\end{itemize}

Задача нахождения пакета для установки иначе называется задачей разрешения 
зависимостей. Это NP-полная задача,  то есть в точной постановке с 
гарантированным ответом нерешаемая. Для ее решения используют приближенные алгоритмы.


Решение приведенной выше задачи разрешения зависимостей является основной функцией 
пакетного менеджера второго уровня, выполнение которой обеспечивает возможность 
установки пользователем любого пакета. В частном случае задача разрешения зависимостей не
имеет решения, если только присутствует серьезное нарушение связи: для
устновки пакету необходимо наличие несущствующего пакета. Следствием 
такой ошибки является некорректная работа пакетного менеджера. Так как 
вся информация о пакетах и их зависимостях отражается в индексе репозитория, 
обнаружить ошибку, приводящую к столь серьезным последствиям, можно с помощью 
контроля состояния индекса.

В  Deepsolver реализован специальный механизм для внесения изменений в индекс 
репозитория, который является частью автоматизированной части пакетного менеджера, 
предназначенной для сборки пакетов. Ошибки в данном механизме влекут за собой 
нарушение целостности индексной информации. Поэтому важным этапом в решении 
проблемы обеспечения актуального состояния индекса является контроль правильности 
работы данного механизма. 

Таким образом, цели настоящей работы могут быть определены, как:
\begin{itemize}
\item
Создание утилиты для проверки готового индекса.
\item
Тестирование утилит для обновления индекса.
\end{itemize}

Помимо обнаружения критических ошибок, немаловажно отслеживать появление 
неактуальных данных, засчет которых неоправданно увеличивается размер индекса. 
Решение этой задачи так же осуществляется вышеописанными утилитами.%??

Прежде чем перейти к описанию реализованных утилит стоит
определить понятие целостности репозитория. Под целостностью
репозитория понимается состояние, которое удовлетворяет следующим
условиям:
\begin{itemize}
\item{Для каждого \textit{require} пакета существует одноименный \textit{provide} 
другого пакета. Require, для которого это условие не выполняется
называется \textit{анметом (unmet)}. }
\item{Для каждого \textit{provide} существует одноименный \textit{require/conflict} или
он находится в директории из заранее заданного списка.Это условие 
контролирует появление избыточных \textit{provide}, засчет которых
может существенно расти размер индекса.}
\item{Для каждого \textit{conflict} пакета существует одноименный \textit{provide} 
другого пакета. Это условие не является таким строгим, как два предыдущих,
но желательно, чтобы оно выполнялось. }
\end{itemize}

Первый этап проверки осуществляется на готовом индексе. На вход утилита 
получает индекс-файл, проводит сбор информации о пакетах и их зависимостях. 
На основании полученных данных првоеряется, удовлетворяет ли текущее состояние 
репозитория условиям целостности. В случае отрицательного ответа выводится 
статистика о найденных ошибках. Обнаружение серьезных ошибок и недоточетов 
на первом этапе тетсирования является индикатором некорректной работы 
механизма обновления индекса. В зависимости от степени серьезности обнаруженных
повреждений, администратор репозитория принимает решение о запуске второго этапа 
тестирования или временном игнорировании.

Целью второго этапа тестирования является обнаружение неполадок в механизме 
обновления. На вход, поступает индекс репозитория, сначала осуществляется 
проверка на неизмененном индексе. После чего запускаются
утилиты для обновления индекса, причем после каждой итерации осуществляется 
проверка измененного индекса. Выводится статистика для каждой проверки, 
на основании которой администратор может более точно локализовать ошибку.

В качестве языка для реализации решения был выбран Python. На данном слайде 
представлена структура модуля, предоставляющего основную функциональность 
для проведения проверки. Объекты класса Package представляют отдельные пакеты 
и содержат информацию о пакете, полученную из индекса: имя пакета и множества 
зависимостей.

Класс IndexParser отвечает за разбор файлов индекса. Основной метод класса 
- \textit{get\_packages\_from\_index\_file} - возвращает генератор массива 
обхектов класса Package, передавая в конструкторе значения полей класса, 
полученных в результате разбора. В языке питон на синтаксическом уровне 
поддерживаются итераторы --- типовое решения для инкапсуляции последовательного 
доступа к элементам объекта-агрегата. Языковая конструкция for принимает на вход 
итерируемые объекты, в данном случае, множество. При вызове генератора функция 
немедленно возвращает объект-итератор, который хранит текущую точку исполнения 
и состояние локальных переменных функции. При запросе следующего значения 
(посредством метода next(), неявно вызываемого в for цикле) генератор продолжает 
исполнение функции от предыдущей точки останова до следующего оператора yield или return.
Тот факт, что метод \textit{get\_packages\_from\_index\_file} возвращает генератор позволяет
его использовать в том числе и для парсинга большого количества файлов большого размера, 
таким образом, что все множество пакетов необязательно должно сохраняться в память ---
при каждой новой итерации будет прочитан следующий один блок файла индекса, 
а содержание предыдущего может быть удалено из ОЗУ.

Класс IndexTestResult предназначен для удобной работы с результатами тестирования 
и их выводом. У класса определен метод diff, получающий на вход объект класса IndexTestResult. 
Результатом его работы является изменение объекта, его вызвавшего, в соответствии
с объектом, полученным в качестве аргумента.

В классе IndexTester определны методы, непосредственно отвечающие за проверку индекса.

Такимо образом, в результате данной ВКР быи разработаны:
Утилита для проверки готового индекса
Утилита для проверки механизма обновления инжекса.

Было проведено тестирование для проверки индексов репозитория пакетного менеджера
Deepsolver.
В течение года производились многократные отладки процедуры обновления
индекса, контроль за влиянием изменений проводился с помощью данных утилит. На дан-
ный момент индексы Deepsolver интегрированы в официальный репозиторий компании ALT Linux.

Описанные в настоящей работе утилиты были применены для проверки целостности индекса, 
на настоящий момент находящегося в промышленном применении.



\end{document}









 




