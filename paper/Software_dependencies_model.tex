\section{Задача разрешения зависимостей}
Ранее упоминалось, что система зависимостей между пакетами довольна сложна. Этот факт 
значительно затрудняет решение проблемы разрешения зависимостей, которая возникает
при потребности пользователя установить новый пакет. Решение этой проблемы является одной
из основных задач менеджеров второго уровня.
Для более ясного понимания проблемы разрешения зависимостей является целесообразным использовать
для представления некоторую формализованную математическую модель.

\subsection{Математическая модель зависимостей между пакетами}
\label{sn:software_dependencies_model}

В модели существует три типа объектов: пакеты, версии пакетов и зависимости.
Пакеты будут обозначаться - $p_1, \dots$; версии - $v_1, \dots$; зависимости 
представляются в виде $v \to {v'_1, \dots}$, это значит, что версия $v$ требует
версии ${v'_1, \dots}$. \\
Пакет, соответствующий версии $v$ обозначается как $PkgOf(v)$.\\
Таким образом, для всей системы имеем следующие множества:
\begin{itemize}
\item{
$\mathcal{P}$ - множество пакетов.
}
\item{
$\mathcal{V}$ - множество версий пакетов,а так же одна дополнительная версия для каждого пакета,
отображающая статус пакета, если он не установлен. Версии, соответствующие некоторому пакету
буду обозначаться как $p: n$, где $n$ - номер версии; ``удаленные'' (``uninstalled'') версии
обозначаются как $p_u$;
}
\item{
$\mathcal{D}$ - множество зависимостей.\\
 Для каждой зависимости версии $v$ пакета от $A_1 | \dots$
создадим множество $S$, содержащее все подходящие версии объявленных пакетов, 
а так же все версии пакетов, реализующих интерфейс объявленных, если в зависимости 
версия не указана.

Например, если $v$ ``объявляет'' зависимость от $A (>= 3.2) | B$, 
доступны версии 3.1, 3.2 и 3.3 пакета A, и версии 1, 2 и 3 пакета B,
кроме того версия 3.14 пакета C реализует интерфейс B. 
Таким образом $S = \{A:3.2,A:3.3,B:1,B:2,B:3,C:3.14\} $. 

$\mathcal{D}$ содержит $v \to S$ для каждой такой зависимости.
}
\item{
Для каждого конфликта версии $v$ с пакетом $p$ создадим множество $S$, содержащее все
неподходящие версии пакета $p$, в том числе и ``удаленные'' версии. Добавляем $v \to S$
в $\mathcal{D}$. Если конфликт не содержит указания на версию, то для каждого пакета $p'$ и $v'$ -
версии $p'$, причем $v'$ реализует интерфейс $p$, положим \\
$S = \{v''|PkgOf(v'') = p' \wedge v'' \text{не реализуют $p$}\} $
и добавим $v \to S$ в $\mathcal{D}$.

Например, если $v$ имеет конфликт с $A$, с доступными версиями 3.2 и 3.3, а версии 2 и 3 пакета $B$
реализуют интерфейс $A$, и нет других версий $B$, то

$S = \{A:3.2, A:3.3, A:UNINST, B:2, B:UNINST\}$
}
\end{itemize}

\subsubsection{Инсталляция пакета}
На данном этапе осуществляется выбор версии пакета для установки. \\

Инсталляция $I$ - функция ставящая в соответствие каждому пакету его версию ---
 устанавливает версию $v$, записывается: $I \rhd v$, если $I(PkgOf(v)) = v$.\\
 
Инсталляция $I$ удовлетворяет зависимости $d = v \to S$, если $I \not\rhd v$
или $I \rhd v'$ для некоторого $v' \in S$.\\

Инсталляция $I$ является совместимой, если $I \vdash d$ для всех $d \in \mathcal{D}$.\\

Если $I$ - инсталляция, тогда $I;p \mapsto v$ есть новая инсталляция, которая устанавливает 
версию $v$ пакета $p$, а остальные оставляет без изменения:\\

$$ (I;p \mapsto v)(p') = \left\{
\begin{array}{l l}
I(p'), & \quad p' \neq p\\
v, & \quad p' = p\\
\end{array}
\right.$$

\subsubsection{Задача разрешения зависимостей}
Пусть $I_0$ - ``несовместимая'' инсталляция. Необходимо найти инсталляцию,
схожую с $I_0$, которая бы удовлетворяла зависимости. Так звучит
задача разрешения зависимостей.\\

В реальных пакетных менеджерах это соответствует ситуациии, когда пользовательский 
запрос на установку, обновление или удаление пакета приводит к некорректному состоянию
(неудовлетворенные зависимости или конфликты). Цель пакетного менеджера 
в этой ситуации --- найти ``наилучшее'' множество изменений, приводящее 
к корректному состоянию.

Так как термин ``наилучшее множество'' является оценочным, необходимо 
выбрать некоторые критерии его оценки, например с наименьшим числом
устанавливаемых, обновляемых или удаляемых пакетов.

В некоторых случаях необходимо позволить пользователю выбирать 
из альтернатив-решений, то, которое ему больше подходит.

\subsubsection{NP-полнота задачи разрешения зависимостей}
Для того, чтобы найти подходящее решение, сначала необходимо найти любое
решение, удовлетворяющее данным зависимостям. Эта задача является NP-полной.

Покажем это ниже.\\

Для этого необходимо свести задачу КНФ-выполнимости к задаче, дающей ответ на 
вопрос: ``Существует ли совместимая инсталляция $I$?''\\

Поставим в соответствие каждой переменной и каждому клозу КНФ пакет. Для
каждой переменной $x$ значение версии соответствующего пакета может быть
$x:0$ или $x:1$, для каждого клоза существует лишь одна версия $v_c$ - 
версия соответствующего пакета. Добавляем $v_c \to S$ в $\mathcal{D}$, где,
для каждого вхождения переменной $x$ в клозе, $S$ содержит $x:0$, если
$x$ в клозе включен с отрицанием, и $x:1$, если без. Сведение выполняется за
полиномиальное время. Данный набор зависимостей разрешим тогда и только тогда,
когда существует решение соответствующей задачи КНФ-выполнимости.\\

Предположим, что существует решение задачи КНФ-выполнимости. Определим инсталляцию 
$I$: если клозу соответствует пакет $p$, то $I(p)$ принимает единственной значение, 
равное версии пакета $p$; если пакет соответствует переменной $x$, то $I(p) = x:0$,
если значение $x$ ложно, и $I(p) = x:1$, если истинно. Рассмотрим некоторую зависимость
$d = v \to S$, где $S$ и $v$ соответствуют некоторому клозу. Значение хотя бы одной
переменной в клозе должно быть истинно, пусть этой переменной будет $x$. Если $x$ 
встречается в клозе без отрицания, то $S$ содержит $x:1$ и $I \rhd x:1$, тогда $I \vdash d$.
Если же переменная употребляется с отрицанием, то в $S$ включается $x:0$ и $I \rhd x:0$, отсюда 
$I \vdash d$. Получаем, что  $I$ - совместимая инсталляция.\\

Предположим обратное: пусть существует некоторая совместимая инсталляция $I$. Всем переменным 
$x$ поставим в соответствие пакет $p$. Если $I(p) = x:1$, то переменная $x$ ложна; если 
$I(p) = x:0$, то переменная $x$ - истинна. Для любого клоза: $\mathcal{D}$ содержит зависимость
$v_c \to S$, где $v_c$ - единственное значение версии пакета, соответствующего клозу. Так как 
необходимо, чтобы $I \rhd v_c$, и $I$ - совместимая инсталляция, существует версия $v' \in S$
такая, что $I \rhd v'$. Но существует  некоторая переменная $x$ такая, что $v$ соответствует 
$x:1$, если $x$ встречается без отрицания, или $x:0$, если с отрицанием. Следовательно, клоз 
выполним и значения, объявленные выше, удовлетворяют всем клозам.

Таким образом, получим, что задача разрешения зависимостей  NP-полная.\\

Несмотря на то, что в общем случае задача разрешения зависимостей принадлежит
классу NP-полных задач, на практике при определенных условия она может быть
решена за полиномиальное время. 

Известно, что многие NP-полные задачи содержат
колоссально различающиеся по сложности случаи, для решения одних подходит использование относительно простых алгоритмов, другие же требует применения более сложных 
техник решения.

В современных система управления пакетами наблюдается склонность к решению простых
случаев, более того, зачастую инсталляция, запрашиваемая пользователем, совместима или почти совместима. 

В большинстве случаев оправдано разрешение зависимостей для конкретного
запроса пользователя путем сужения рассмотрения лишь до небольшой части графа зависимостей. 
К примеру, путем введения запрета на удаление библиотек ядра. Таким образом, определить,
решается проблема или нет, можно на основании анализа ранее ограниченной части графа.

Даже при применении относительно простых техник для поиска решения сложность заключается
не в недостаточном количестве решений, а скорее в их избытке, то есть найти любое решение
просто, а поиск правильного решения - довольно сложная задача.
 




