\subsubsection{Схема обновления репозитория}
Добавление нового пакета или публикация обновления уже существующего
может повлечь существенные изменения индекса, вызванные в том числе
необходимостью учитывать связи между пакетами, на данный момент не
отраженные в индексе из-за их неактуальности. Стоит заметить, что 
каждый пакет хранит информацию о своих зависимостях, а пакетный
менеджер определяет, какая информация является актуальной, то есть
должна быть отражена в индексе.\\
Ниже рассмотрим возможные изменения индекса, вызванные различными
компонентами добавляемого пакета:
\begin{itemize}
\item
Добавляемый пакет в качестве одной из зависимостей указывает \textit{provide}
другого пакета, который ранее не был отражен в индексе. Подобная ситуация
возникает в том случае, если ранее данному \textit{provide} не соответствовало ни 
одного \textit{require}, то есть он классифицировался, как избыточный и удалялся
из индекса. Как следствие, теперь необходимо для каждого пакета, содержащего
требуемый \textit{provide}, обновить индекс-информацию.
\item
Добавляемый пакет указывает в тэге \textit{provide}, что предоставляет функциональность,
необходимую другому пакету для установки, причем ранее ее никто не предоставлял. В таком
случае необходимо добавить этот пакет в индекс. 
Такое поведение порождает рекуррентное обновление индекса.
\item
По аналогии с \textit{provide}, для каждого пакета с \textit{conflict}, ранее считавшимся
избыточными, необходимо обновить индекс-информацию.

\end{itemize}

Приведенные выше случаи наглядно иллюстрируют сложность задачи обновления индекса, а 
следовательно, сложность создания утилит для корректного ее решения и высокую вероятность
возникновения ошибок на ранних этапах разработки. Воизбежании этого необходимо вести
тщательное наблюдение за работой данных утилит.
